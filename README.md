# Области видимости и декораторы

## Аннотация

Данный проект позволит Тебе подробнее изучить, что такое декораторы, как их писать и как ими пользоваться. 

## Содержание

1. [Chapter I](#chapter-i) \
    1.1. [Общая инструкция](#общая-инструкция) \
    1.2. [Введение](#введение)
2. [Chapter II](#chapter-ii) \
    2.1. [Задание 1](#задание-1)
3. [Chapter III](#chapter-iii) \
    3.1. [Области видимости](#области-видимости) \
    3.2. [Присваивание функций](#присваивание-функций) \
    3.3. [Задание 2](#задание-2)
4. [Chapter IV](#chapter-iv) \
    4.1. [Декораторы](#декораторы) \
    4.2. [Задание 3](#задание-3) \
    4.3. [Еще немного о декораторах](#еще-немного-о-декораторах) \
    4.4. [Задание 4](#задание-4) \
    4.5. [Задание 5](#задание-5)
5. [Chapter V](#chapter-v) \
    5.1. [Бонусное задание 1](#бонусное-задание-1) \
    5.2. [Бонусное задание 2](#бонусное-задание-2)

## Chapter I

### Общая инструкция

Привет, студент! \
Рады приветствовать тебя на нашем интенсиве по языку Python. \
Перед тем как начать, хочется сказать тебе несколько напутствий:
1. Наша команда - не медики. Если ты будешь видеть в тексте медицинские неточности или ошибки, заранее просим у тебя прощения. Оставляй нам обратную связь и мы все поправим!
2. Повествование ведется иногда немного в шутливой форме, чтобы не быть скучным. Однако, как ты и сам знаешь, юмор и шутки - это субъективная вещь. Поэтому, если каламбуры в данном тексте по твоему мнению попахивают батиным юмором, то, пожалуйста, просто прими это.
3. Не забывай, что отсутствие подробной теории и примеров - это не баг, а фича, как любят говорить разработчики. Не забывай, что Google, а теперь уже и ChatGPT - это верные помощники программиста!
4. Упоминая ChatGPT, хочется отметить, что на данном этапе он всё еще может часто ошибаться. Поэтому, доверяй, но проверяй!
5. Если ты на чем-то застрял и кажется, что уже все перепробовал и не знаешь куда идти - передохни! Поверь, этот совет помогал многим разработчикам в их работе. Проветрись, перезагрузи голову и, возможно, в следующий раз тебе в голову придет нужное решение!
6. **Жирным** шрифтом будут выделены слова на которые тебе нужно будет обратить более пристальное внимание, не стесняйся их гуглить!
7. *Курсивом* будут выделены имена папок и файлов, названия проектов и т.д.
8. В таком блоке `a = 10 * 3` будут представлены куски кода или те строки, которые должны выводится кодом.
9. В такой блок `<вставь сюда данные>` (отличается от верхнего - скобками < >) нужно подставить что-то из твоего кода, возможно какую-то переменную.
10. Перед выполнением проекта необходимо склонировать с GitLab одноименный репозиторий.
11. Все файлы с кодом необходимо создавать в папке *src/* склонированного репозитория.
12. Каждое задание необходимо выполнять в отдельном файле. Название должно содержать *task_* и номер задания. Пример, *task_1.py*, *task_2.py* и т.д. 
Если задание подразумевает создание дополнительных файлов, то их местоположение в папке *src* и названия будут прописаны в теле задания.

Удачи тебе в этом тернистом, но определенно Полезном пути!

### Введение

Ты слышишь, как открывается дверь и уже готов увидеть глав-врача, входящего в кабинет.

> Доброе утро!
>> Стажер

Немного странно осознавать, что несмотря на небольшие причуды, ты уже успел проникнуть уважением к здешнему глав-врачу, и
с энтузиазмом приветствуешь его.

> Привет! Я смотрю, что ты уже ждешь меня? Ахахаха, похвально, похвально! Ну что ж, постараюсь тебя не разочаровать!
> 
> Как ты уже понял, мы пошли с тобой изучать более продвинутые темы. Так не будем останавливаться! Ты уже немного узнал о функциональном
> программировании, пора изучить одну интересную тему - декораторы.
> 
> Предлагаю изучать эту тему на двух задачах:
> 1. Авторизация пользователя по логину и паролю.
> 2. Логирование.
>> Глав-врач

## Chapter II

### Задание 1

> Начнем с авторизации. Давай пока просто вспомним функциональное программирование. Декораторы на самом деле сильно завязаны
> на этот стиль программирования. В файле [*src/task_1.py*](src/task_1.py) я подготовил тебе две функции:
> 1. Функция `stub_write_recipe` имитирует формирование рецепта для пациента.
> 2. Функция `stub_add_to_schedule` имитирует запись пациента к врачу.
> 
> В файле [*materials/users.json*](materials/users.json) содержатся логины и пароли сотрудников больницы с их ролью - врач
> или медсестра.
> 
> Для начала тебе необходимо:
> 1. Написать функцию `check_login_password`, которая должна принимать два аргумента:
>   - функцию, которую необходимо будет выполнить;
>   - словарь с логинами и паролями, считанный с файла [*materials/users.json*](materials/users.json).
> 2. Функция `check_login_password` должна:
>   - запрашивать логин и пароль пользователя с клавиатуры;
>   - проверять, что они совпадают с логином и соответствующим ему паролем из переданного словаря;
>   - если совпадают, то необходимо выполнять переданную в качестве аргумента функцию и возвращать ее результат;
>   - если НЕ совпадают, то инициировать исключение `PermissionError` со следующим текстом - `Неверные логин или пароль!`.
> Как инициировать (или же возбуждать исключения), ты можешь вспомнить из проекта 3.
> 3. Считай файл и сделай вызовы функции `check_login_password` отдельно с двумя функциями: `stub_write_recipe` и `stub_add_to_schedule`
> в блоке `if __name__ == '__main__':`. Проверь себя таким образом, выводя результат на экран. Вводи существующие и несуществующие
> логин или пароль.
> 4. Не забудь про проставление аннотаций во всех местах, где их только можно проставить.
>> Глав-врач

Как же приятно, когда не нужно самому декомпозировать задачу, а за тебя это все уже сделали. Остается только запомнить, что
код надо реализовывать в уже созданном файле [*src/task_1.py*](src/task_1.py).

## Chapter III

### Области видимости

> Итак, в данной реализации функция `check_login_password` принимает два аргумента - другую функцию и словарь с паролями.
> Каждый раз нам нужно будет передавать этот словарь в качестве параметра для этой функции при ее вызове. Однако, существует
> еще один способ, как можно обращаться к переменным изнутри функции. Для этого необходимо понимать **области видимости переменных**.
> То есть откуда в коде видны (то есть их можно использовать) те или иные переменные.
> 
> Существует три **области видимости**:
> 1. **Глобальная**.
> 2. **Локальная**.
> 3. **Нелокальная**.
> 
> С **глобальной** все просто. Все переменные, которые записаны внутри файла с кодом, но не внутри функций или классов - являются **глобальными**.
> **Глобальные переменные** видны из любой части кода, из любой функции или класса. У программистов Python есть договоренность,
> объявлять такие переменные в верхнем регистре. Это позволяет сразу в коде понять, что переменная глобальная. Пример:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   print(EXAMPLE_VARIABLE * 2)
> 
> func()
> ```
> 
> Однако, есть один нюанс. **Глобальные переменные** можно читать и использовать внутри функций или методов. Но если вы попробуйте
> объявить такую же переменную внутри функции, то это уже будет другая переменная, которая будет отдельно существовать внутри
> этой функции! Например, попробуй скопировать куда-нить этот код и выполнить:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   EXAMPLE_VARIABLE = 20
>   print(f'Это переменная EXAMPLE_VARIABLE внутри функции - {EXAMPLE_VARIABLE}')
> 
> func()
> print(f'А это переменная EXAMPLE_VARIABLE, заданная снаружи - {EXAMPLE_VARIABLE}')
> ```
> 
> Если же изнутри функции хочется изменить глобальную переменную, то нужно сделать определенное действие, а именно:
> ```python
> EXAMPLE_VARIABLE = 10
> 
> def func():
>   global EXAMPLE_VARIABLE
>   EXAMPLE_VARIABLE = 20
>   print(f'Это переменная EXAMPLE_VARIABLE внутри функции - {EXAMPLE_VARIABLE}')
> 
> func()
> print(f'А это переменная EXAMPLE_VARIABLE, заданная снаружи - {EXAMPLE_VARIABLE}')
> ```
> а именно написать строчку - `global EXAMPLE_VARIABLE`, она и говорит питону, что можно править глобальную переменную отсюда.
> 
> Это были буквально вводные пару слов, с остальными областями видимости - **локальной** и **нелокальной**, а также подробнее с **глобальной** разберись сам.
> Вот неплохая [статья](https://habr.com/ru/companies/otus/articles/487952/) на хабре на эту тему
>> Глав-врач

### Присваивание функций

> Знаешь, чем мне не нравится код из первого задания? Какова наша цель? Чтобы перед запуском какой-либо функции была осуществлена
> авторизация, чтобы левые люди не могли пользоваться программой. Но проблема в том, что с подходом из первого задания нам
> приходится вместо вызова отдельных функций писать вызов функции `check_login_password` и туда уже передавать нужную функцию. Хотелось
> бы, чтобы мы все-таки вызывали ту же самую функцию.
> 
> Какие есть идеи? Можно конечно в каждую из функций накопировать кусок кода с проверкой логина и пароля. Но представь, что
> функций не 2, а 50. Тебе придется копировать очень много раз. А теперь в какой-то момент логика меняется и тебе нужно снова
> править в 50 местах этот код. Нет, это неправильный подход, такие куски должны быть определены в одном месте, чтобы их можно
> было легко менять в дальнейшем.
> 
> И вот тут нам помогут твои новые знания о функциональном программировании. Что там можно в питоне делать с функциями, помнишь?
> В первом задании ты уже передаешь функцию в качестве аргумента. Но еще ее можно возвращать, а также присваивать другой переменной!
> 
> Используя эти особенности, можно переопределить любую функцию следующим образом:
> ```python
> def external_func(func):
>   print('Приветики-пистолетики')
>   return func
>
> def some_func(a, b):
>   return a + b
> 
> some_func = external_func(some_func)
> print(some_func(10, 3))
> ```
> 
> Скопируй этот пример в какой-нить временный файл и выполни. Ты увидишь, что помимо выполнения действий внутри функции - 
> выполнился еще и принт. То есть по факту мы добавили новый функционал к функции `some_func`!
> 
> Разберись, что происходит в данном примере. Обрати внимание на то, что сам объект функции `some_func` и вызов этой
> функции `some_func()` - это две разные вещи! Объект функции- это специальная структура в памяти, хранящая внутри себя код этой функции, а вызов функции - это
> уже исполнение этого кода. Ты можешь написать - `print(some_func)` и `print(type(some_func))` и посмотреть, что будет.
>> Глав-врач

### Задание 2

> Если ты разобрался в чем тут фишка, то может показаться, что это круто. Мы в одной функции можем дописать код, который
> будет дополнять сразу куча других функций. Однако, все не так радужно. Я подготовил тебе [файл с кодом](src/task_2.py).
> В нем я уже подготовил переопределение двух функций - `stub_write_recipe` и `stub_add_to_schedule` с помощью функции 
> `check_login_password`, а также написал логику вызова этих функций и еще сверху пару принтов. Тебе остается:
> 1. Определить переменную с глобальным словарем `DICT_USERS` с логинами и паролями.
> 2. Написать функцию `check_login_password`, которая принимает один аргумент - другую функцию. Внутри эта функция должна:
>     - запрашивать логин и пароль с клавиатуры и проверять их в глобальной переменной `DICT_USERS`;
>     - если проверка провалена, то вызывать тоже исключение, что и в задании 1;
>     - если такие логин и пароль присутствуют в словаре, то необходимо выводить на экран фразу `Сигнал из функции`, а затем
> возвращать переданную в качестве аргумента ФУНКЦИЮ (заметь, что ее **НЕ НАДО** вызывать и возвращать результат, нужно вернуть
> саму функцию, как объект). 
> 3. После этого необходимо выполнить код и посмотреть порядок вывода на экран надписей и понять в какой момент исполнения кода выполняется
> тот или иной принт.
>> Глав-врач

## Chapter IV

### Декораторы

> Надеюсь ты заметил, что `Сигнал из функции` печатается на экран на следующих моментах:
> ```python
> stub_write_recipe = check_login_password(stub_write_recipe)
> stub_add_to_schedule = check_login_password(stub_add_to_schedule)
> ```
> а не при вызове функций (`stub_write_recipe()` и `stub_add_to_schedule()`).
> 
> Это тоже не то, что мы хотим. Мы хотим, чтобы блок кода, связанный с авторизацией выполнялся именно во время вызова функций
> `stub_write_recipe` и `stub_add_to_schedule`, а не во время их переопределений. Чтобы этот кусок кода выполнялся при вызове,
> необходимо обернуть всю основную логику функции `check_login_password` во вложенную функцию, которую и следует уже возвращать. Давай посмотрим на примере:
> ```python
> def external_func(func):
>   def wrapper(a, b):
>       print('Приветики-пистолетики')
>       return func(a, b)
>   return wrapper
>
> def some_func(a, b):
>   return a + b
> 
> some_func = external_func(some_func)
> print('Промежуточный сигнал')
> print(some_func(10, 3))
> ```
> Выполни этот код и посмотри порядок вывода принтов. В данном случае `Приветики-пистолетики` будут выводиться на экран уже
> во время выполнения функции (`print(some_func(10, 3))`), а не во время переопределения (`some_func = external_func(some_func)`).
> Заметь кстати, что из функции `wrapper` мы обращаемся к аргументу `func`, который не передается в качестве аргумента для `wrapper` напрямую,
> а находится на уровень выше - привет области видимости. Также функция `wrapper` уже возвращает РЕЗУЛЬТАТ, а не функцию как объект.
> 
> Попробуй разобраться по шагам, что тут вообще происходит. Если супер упрощенно - то вложенная функция нужна, чтобы возвращать
> именно ее, как объект. Это позволяет вызывать блок кода вложенной функции именно во время выполнения переопределенной функции.
> Я уверен, что это ломает тебе сейчас мозг. Это нормально, такое надо осознать, а также найти и прочитать более существенные
> разъяснения.
> 
> Кстати, чуть не забыл, вот эта функция `external_func` и есть **декоратор**, то есть специальная функция,
> которая позволяет добавить новую функциональность к другой функции, не изменяя ее исходный код.
> 
> Последнее, что скажу. В разных языках программирования есть такое понятие, как **синтаксический сахар**. Это когда
> язык позволяет записать какой-то смысловой код в более сокращенном виде. Так вот для **декораторов** в питоне есть свой
> синтаксический сахар для переопределения функции - `some_func = external_func(some_func)`. А именно:
> ```python
> def external_func(func):
>   def wrapper(a, b):
>       print('Приветики-пистолетики')
>       return func(a, b)
>   return wrapper
>
> @external_func
> def some_func(a, b):
>   return a + b
>
> print('Промежуточный сигнал')
> print(some_func(10, 3))
> ```
> 
> А вот и он - `@external_func`. Чтобы переопределить функцию с помощью **декоратора**, нужно над функцией написать знак собаки `@`
> и название декоратора.
>> Глав-врач

### Задание 3

> Ну что, предлагаю в подготовленном мной [файле](src/task_3.py):
> 1. Написать функцию `check_login_password`, как нормальный **декоратор**.
> 2. С помощью **синтаксического сахара** (в дальнейшем это будет подразумеваться по-умолчанию для всех декораторов) обернуть
> функции `stub_write_recipe` и `stub_add_to_schedule` в декоратор `check_login_password`.
> 3. Предлагаю завести две глобальные переменные `DICT_USERS` и `IS_AUTHORIZED`. Для чего нужна первая, ты уже догадываешься.
> А вот вторую переменную я предлагаю использовать в следующем контексте. Раньше мы вводили логин и пароль при вызове КАЖДОЙ
> функции. На самом деле это странно, во время запуска программы за компьютером будет сидеть один человек. Зачем его по сто раз
> спрашивать логин и пароль. Ты же при использовании, например, почты не вводишь логин и пароль при каждом чихе, а делаешь это всего один раз,
> в самом начале. Поэтому предлагаю внутри декоратора (здесь всегда подразумевается вложенная функция декоратора):
>   - запрашивать логин и пароль только при первом использовании этого декоратора, то есть при вызове первой функции, которая
> обернута в этот декоратор. Здесь же проверять логин и пароль в словаре `DICT_USERS` и возбуждать исключение при неверных логине
> или пароле.
>   - если же это второй или далее вызов любой функции, обернутой в декоратор, то просто возвращать значение функции.
> 
>   Вот для этого я и советую использовать глобальную БУЛЕВУЮ переменную `IS_AUTHORIZED`, значение которой можно менять после
> первого ввода логина и пароля (не забудь про особенности изменения глобальной переменной изнутри функции - см. области видимости).
> На этом мои подсказки, как использовать эту переменную, заканчиваются.
> 4. Не забудь про аннотации!
>> Глав-врач

### Еще немного о декораторах

> И еще две вещи о **декораторах**.
> 
> Первая вещь - это то, что на функцию можно навешивать сколько угодно декораторов:
> ```python
> def decorator_1(func):
>   def wrapper(a, b):
>       print('Декоратор 1')
>       return func(a, b)
>   return wrapper
> 
> 
> def decorator_2(func):
>   def wrapper(a, b):
>       print('Декоратор 2')
>       return func(a, b)
>   return wrapper
>
> @decorator_2
> @decorator_1
> def some_func(a, b):
>   return a + b
>
> print(some_func(10, 3))
> ```
> В каком порядке они будут выполняться - проверь сам.
> 
> И вторая вещь - можно создавать **декораторы**, которые принимают аргументы на вход. Реализация их не такая очевидная, 
> как может прийти в голову. Но это уже часть твоего задания - разберись, как такие **декораторы** (принимающие аргументы) создаются.
>> Глав-врач

### Задание 4

> А теперь давай наконец расширим наш функционал с авторизацией по-максимуму. Я хочу, чтобы ты в подготовленном мной [файле](src/task_4.py):
> 1. Написал два декоратора:
>   - `check_login_password`, который не принимает аргументов. Декоратор должен делать все то же самое, что и в задании 3,
> и помимо этого при верной авторизации (логин и пароль верные), необходимо записывать в **ГЛОБАЛЬНУЮ** переменную `USER_ROLE`
> роль пользователя из словаря `DICT_USERS` - `doctor` или `nurse`. Опять же, как и с переменной `IS_AUTHORIZED` делать это нужно один
> раз при первом использовании этого декоратора;
>   - `has_permission`, который принимает один аргумент `permission`, являющийся списком. Аргумент `permission` содержит список
> ролей, которым разрешено выполнение функции, которая оборачивается этим декоратором. Пример значения аргумента - `['doctor', 'nurse']`. Это означает, что функция
> обернутая декоратором с таким аргументом будет доступна для роли врача и медсестры. Внутри, декоратор должен проверять входит ли
> роль из глобальной переменной `USER_ROLE` в переданный список `permission`. Если входит, то необходимо выполнять обернутую декоратором функцию.
> Если не входит, то генерировать исключение - `PermissionError(f'У <подставить роль из USER_ROLE> нет прав выполнять функцию <подставить имя функции>!')`.
> Пример сообщения исключения в терминале - `У nurse нет прав выполнять функцию stub_write_recipe!`
> 2. Навесил на функции `stub_write_recipe` и `stub_add_to_schedule` декоратор `check_login_password` и декоратор `has_permission`.
> 3. Пусть функция `stub_write_recipe` выполняется только для роли **доктор**, а функция `stub_add_to_schedule` для ролей **доктор**
> и **медсестра**.
> 4. Очередность выполнения декораторов следующая - вначале проверка логина и пароля, потом проверка роли.
> 5. Не забудь про аннотации!
>> Глав-врач

### Задание 5

> Ты проделал хорошую работу сегодня. И я даю тебе выбор, либо запушить свои задачи в GitLab и немного передохнуть, либо 
> же выполнить еще две задачи, чтобы закрепить тему с декораторами. Выбор за тобой
>> Глав-врач

Хм, надо подумать, но в любом случае не помешает **запушить** текущие 4 задачи в GitLab.

## Chapter V

### Бонусное задание 1

> О, так ты решил остаться и закрепить свои знания. Очень похвально! Тогда не будем тянуть и сразу к делу.
> 
> В этом [файле](src/task_bonus_1.py) я подготовил тебе также две функции - `signature_name`, которая принимает два аргумента,
> один из которых имеет значение по-умолчанию, и `stub_add_to_schedule`, которая имеет два позиционных аргумента.
> 
> Я хочу, чтобы ты написал декоратор `log_execution_time`, который **логирует** в файл *src/execution_log_1.log* запись о выполнении
> функции (которая обернута этим декоратором) и с какими аргументами она была выполнена, ну и естественно выполняет саму функцию. В файл необходимо дозаписывать данные, а не создавать каждый раз заново файл
> при любом запуске. Пример строчек с **логами** для двух запусков (которые присутствуют в [файле с кодом](src/task_bonus_1.py))
> можно посмотреть [тут](materials/execution_log_1.log). Я надеюсь понятно, что в `args=()` должны записываться те аргументы,
> которые были переданы позиционно, а в `kwargs={}` те аргументы, которые были переданы в формате - `func(a=10)`.
> Кстати реализуй в декораторе возможность, чтобы я мог передавать в функции `signature_name` и `stub_add_to_schedule`
> аргументы в абсолютно любом виде - в виде позиционных или именных.
> 
> Ну и не забудь, что нужно подставлять имя той функции, которая сейчас выполняется. Реализуй логирование вручную, не используя никаких библиотек.
> 
> И не забудь обернуть функции `signature_name` и `stub_add_to_schedule` в декоратор `log_execution_time`! Кстати, декоратор
> здесь не должен принимать никаких аргументов.
>> Глав-врач

> Извините, пожалуйста, а что такое **логирование** и логи? 
>> Стажер

> Совсем забыл, что ты можешь этого не знать! Все просто, **логирование** - это процесс записи каких-то событий, выполнения функций, 
> фиксирования каких-то сообщений из программы. Строчки-записи называются **логами**. **Логи** можно записывать в специальные программы,
> выводить на экран (`print()` - тоже своего рода можно назвать логом) или же записывать в файл. **Логирование** повсеместно
> встречается во всех больших программных обеспечениях или небольших программах. Иначе, если что-то пойдет не так, ты не отследить, что
> произошло. Ну или же просто надо собрать статистику, например, сколько пользователь нажал на рекламу на сайте. Все эти события
> **логируются** и к ним в дальнейшем можно обратиться. 
> 
> А теперь вперед! И не забудь про аннотации!
>> Глав-врач

Ну что ж, надо реализовать код в [данном файле](src/task_bonus_1.py) и после **запушить** его в GitLab!

### Бонусное задание 2

> Если ты еще не собираешься домой, то давай на сегодня последнюю задачку. Это правда последняя!
> 
> Возможно ты уже догадываешься, что в Python под очень многие частые задачи существуют готовые модули. Так и с **логированием**.
> Используй в этот раз библиотеку `logging`, задай через `logging.basicConfig` основные параметры логов, включая файл, 
> куда они будут записываться - *src/execution_log_2.log*, формат даты и т.д. Уровень логов поставь на `INFO`.
> Да и вообще разберись, как работает библиотеку `logging`. Твоя задача, используя библиотеку `logging` поправить декоратор
> `log_execution_time` переписав всю часть с логами на эту библиотеку.
> 
> При этом расширь функционал декоратора таким образом, чтобы если функция во время выполнения падала с ошибкой `TypeError`
> (эта ошибка обычно падает, когда что-то не так с передачей аргументов в функцию), то в файл с логами записывалось бы ПОЛНОЕ
> сообщение об ошибке, а декоратор при этом возвращал `None`.
> 
> Пример строчек с **логами** для четырех запусков (которые присутствуют в [файле с кодом](src/task_bonus_2.py))
> можно посмотреть [тут](materials/execution_log_2.log).
> 
> И не забудь про аннотации!
> 
> Как сделаешь - можешь быть свободен до завтра. И так держать, осталось совсем чуть-чуть до конца твоей стажировки, держись!
>> Глав-врач

Что-то ты сегодня засиделся, надо уже реализовать этот код в [этом файле](src/task_bonus_2.py), **запушить** его в GitLab и наконец
идти домой.

💡 [Нажми тут](https://forms.gle/fB11jp4JZ6KkgEJs9),чтобы поделиться с нами обратной связью на этот проект в рамках тестирования. Это поможет команде Продукта сделать обучение лучше. Спасибо за участие!

